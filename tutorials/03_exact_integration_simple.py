from __future__ import division, print_function

print("""
Numerical homogenisation based on exact integration, which is described in
J. Vondrejc, Improved guaranteed computable bounds on homogenized properties
of periodic media by FourierGalerkin method with exact integration,
Int. J. Numer. Methods Eng., 2016.

This is a self-contained tutorial implementing scalar problem in dim=2 or dim=3
on a unit periodic cell Y=(-0.5,0.5)**dim
with a square (2D) or cube (3D) inclusion of size 0.6 (side).
The material is identity I in matrix phase and 11*I in inclusion phase.
""")

import numpy as np
import itertools
from scipy.sparse.linalg import cg, LinearOperator

dim = 3 # number of spatial dimensions
N = dim*(5,) # number of discretization points
dN = tuple(2*np.array(N)-1) # double grid value
vec_shape=(dim,)+dN

# indicator function indicating the phase per grid point (square inclusion)
P = dim*(5,) # material resolution in each spatial dimension
phi = np.zeros(P, dtype='float')
if dim==2:
    phi[1:4, 1:4] = 1
elif dim==3:
    phi[1:4, 1:4, 1:4] = 1

# material coefficients at grid points
C = np.einsum('ij,...->ij...', 11*np.eye(dim),   phi)
C += np.einsum('ij,...->ij...', 1*np.eye(dim), 1-phi)

# tensor products / (inverse) Fourier transform / frequencies
dot = lambda A, B: np.einsum('ij...,j...->i...', A, B)
fft = lambda x, N: np.fft.fftshift(np.fft.fftn(np.fft.ifftshift(x), N))/np.prod(np.array(N))
ifft = lambda x, N: np.fft.fftshift(np.fft.ifftn(np.fft.ifftshift(x), N))*np.prod(np.array(N))
freq_fun = lambda N: np.arange(np.fix(-N/2.), np.fix(N/2.+0.5))
freq = [freq_fun(n) for n in dN]

def get_weights(h): # calculation of integral weights of rectangular function
    Wphi = np.zeros(dN) # integral weights
    for ind in itertools.product(*[range(n) for n in dN]):
        Wphi[ind] = np.prod(h)
        for ii in range(dim):
            Wphi[ind] *= np.sinc(h[ii]*freq[ii][ind[ii]])
    return Wphi

def decrease(val, dN): # auxiliary function to remove unnecesary Fourier freq.
    dN=np.array(dN)
    N=np.array(val.shape[-dN.size:])
    ibeg = np.array(np.fix((N-dN+(dN % 2))/2), dtype=np.int)
    iend = np.array(np.fix((N+dN+(dN % 2))/2), dtype=np.int)
    if dN.size==2:
        return val[:,:,ibeg[0]:iend[0],ibeg[1]:iend[1]]
    elif dN.size==3:
        return val[:,:,ibeg[0]:iend[0],ibeg[1]:iend[1],ibeg[2]:iend[2]]

## GRID-BASED COMPOSITE ######### evaluate the matrix of Galerkin approximation
hC0 = np.prod(np.array(P))*fft(C, P)
if P == dN:
    hCex = hC0
elif P > dN:
    hCex = decrease(hC0, dN)
elif P < dN:
    factor = np.max(np.ceil(np.array(dN) / np.array(P)))
    hCper = np.tile(hC0, int(2*factor-1)*np.ones(dim, dtype=np.int))
    hCex = decrease(hCper, dN)
Cex = ifft(np.einsum('ij...,...->ij...', hCex, get_weights(1./np.array(P))), dN).real

## INCLUSION-BASED COMPOSITE #### another expression of Cex
Wraw = get_weights(0.6*np.ones(dim))
"""HINT: the size 0.6 corresponds to the size of square inclusion; it is exactly
the size of topology generated by phi, i.e. 3x3 pixels in 5x5 image of PUC with
PUC size 1; then 0.6 = 3./5.
"""
char_square = ifft(Wraw, dN).real
Cex2 = np.einsum('ij...,...->ij...', 11*np.eye(dim),   char_square)
Cex2 += np.einsum('ij...,...->ij...', 1*np.eye(dim), 1.-char_square)

## checking that the Cex2 is the same
print('zero check:', np.linalg.norm(Cex-Cex2))

Gamma = np.zeros((dim,dim)+ tuple(dN)) # zero initialize
for i,j in itertools.product(range(dim),repeat=2):
    for ind in itertools.product(*[range(int((dN[k]-N[k])/2), int((dN[k]-N[k])/2+N[k])) for k in range(dim)]):
        q = np.array([freq[ii][ind[ii]] for ii in range(dim)])  # frequency vector
        if not q.dot(q) == 0:          # zero freq. -> mean
            Gamma[(i,j)+ind] = -(q[i]*q[j])/(q.dot(q))

# - convert to operators
G  = lambda X: np.real(ifft(dot(Gamma, fft(X, dN)), dN)).reshape(-1)
A  = lambda x: dot(Cex, x.reshape(vec_shape))
GA = lambda x: G(A(x))

# initiate strain/stress (2nd order tensor for each grid point)
X = np.zeros(vec_shape, dtype=np.float)
x = X.reshape(-1)
# macroscopic value
E = np.zeros_like(X); E[0] = 1.
b = -GA(E.reshape(-1))

# iterative solution of the linear system
Alinoper = LinearOperator(shape=(x.size, x.size), matvec=GA, dtype=np.float)
x, info = cg(A=Alinoper, b=b, x0=X.reshape(-1)) # conjugate gradients
state = x.reshape(vec_shape) + E
flux = dot(Cex, state)

AH_11 = np.sum(flux*state)/np.prod(np.array(dN)) # homogenised properties
print('homogenised coefficient (component 11) =', AH_11)

print('END')
