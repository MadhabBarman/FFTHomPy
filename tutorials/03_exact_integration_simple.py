print("""
Numerical homogenisation based on exact integration, which is described in
J. Vondrejc, Improved guaranteed computable bounds on homogenized properties
of periodic media by FourierGalerkin method with exact integration,
Int. J. Numer. Methods Eng., 2016.

This is a self-contained tutorial implementing scalar problem in dim=2
on a unit periodic cell Y=(-0.5,0.5)x(-0.5,0.5)
with a square inclusion of size 0.6 (side).
The material is identity I in matrix and 10*I in inclusion.
""")

import numpy as np
import itertools
from scipy.sparse.linalg import cg, LinearOperator


dim = 2 # number of spatial dimensions
N = 5 # number of discretization points
dN = 2*N-1 # double grid value
# HINT: you get the same solution for any odd dN higher than 2*N-1, e.g. 2*N+1

# indicator function indicating the phase per grid point (square inclusion)
P = 5 # material resolution in each spatial dimension
phi = np.zeros(dim*[P], dtype='float')
phi[1:4, 1:4] = 1

# material coefficients at grid points
C = np.einsum('ij,xy->ijxy', 11*np.eye(dim),   phi)
C += np.einsum('ij,xy->ijxy', 1*np.eye(dim), 1-phi)

# tensor products / (inverse) Fourier transform / frequencies
dot = lambda A, B: np.einsum('ij...,j...->i...', A, B)
fft = lambda x, N: np.fft.fftshift(np.fft.fftn(np.fft.ifftshift(x), dim*[N]))/N**dim
ifft = lambda x, N: np.fft.fftshift(np.fft.ifftn(np.fft.ifftshift(x), dim*[N]))*N**dim
freq_fun = lambda N: np.arange(np.fix(-N/2.), np.fix(N/2.+0.5))
freq = freq_fun(dN)

def get_weights(h): # calculation of integral weights of rectangular function
    Wphi = np.zeros(dim*[dN]) # integral weights
    bw = lambda xi: np.sinc(h*xi) # basic weight
    for ii, jj in itertools.product(list(range(dN)), repeat=dim):
        Wphi[ii, jj] = h**dim*bw(freq[ii])*bw(freq[jj])
    return Wphi

def decrease(val, dN): # auxiliary function to remove unnecesary Fourier freq.
    ibeg = np.array(np.fix((3*N-dN+(dN % 2))/2), dtype=np.int)
    iend = np.array(np.fix((3*N+dN+(dN % 2))/2), dtype=np.int)
    return val[:,:,ibeg:iend,ibeg:iend]

## GRID-BASED COMPOSITE ######### evaluate the matrix of Galerkin approximation
hC0 = P**dim*fft(C, P)
if P == dN:
    hCex = hC0
elif P > dN:
    hCex = decrease(hC0, dN)
elif P < dN:
    factor = np.int(np.ceil(float(dN) / P))
    hCper = np.tile(hC0, (2*factor-1)*np.ones(dim, dtype=np.int))
    hCex = decrease(hCper, dN)
Cex = ifft(np.einsum('ij...,...->ij...', hCex, get_weights(1./P)), dN).real

## INCLUSION-BASED COMPOSITE #### another expression of Cex
Wraw = get_weights(0.6)
"""HINT: the size 0.6 corresponds to the size of square inclusion; it is exactly
the size of topology generated by phi, i.e. 3x3 pixels in 5x5 image of PUC with
PUC size 1; then 0.6 = 3./5.
"""
char_square = ifft(get_weights(0.6), dN).real
Cex2 = np.einsum('ij...,...->ij...', 11*np.eye(dim),   char_square)
Cex2 += np.einsum('ij...,...->ij...', 1*np.eye(dim), 1.-char_square)

## checking that the Cex2 is the same
print('zero check:', np.linalg.norm(Cex-Cex2))

# projection operator
Gamma  = np.zeros([dim, dim, dN, dN], dtype=np.float)
for i, j in itertools.product(range(dim), repeat=2):
    for x, y in itertools.product(range(int((dN-N)/2), int((dN-N)/2+N)), repeat=dim):
        q = np.array([freq[x], freq[y]]) # frequency vector
        # Gamma non-zero only for non-zero frequency (associated with the mean)
        if not q.dot(q) == 0:
            Gamma[i,j,x,y] = q[i]*q[j]/(q.dot(q))

# - convert to operators
G  = lambda X: np.real(ifft(dot(Gamma, fft(X, dN)), dN)).reshape(-1)
A  = lambda x: dot(Cex, x.reshape(dim, dN, dN))
GA = lambda x: G(A(x))

# initiate strain/stress (2nd order tensor for each grid point)
X = np.zeros([dim,dN,dN], dtype=np.float)
x = X.reshape(-1)
# macroscopic value
E = np.zeros_like(X)
E[0, :, :] = 1.
b = -GA(E.reshape(-1))
# iterate as long as the residual does not vanish

# iterative solution of the linear system
Alinoper = LinearOperator(shape=(x.size, x.size), matvec=GA, dtype=np.float)
x, info = cg(A=Alinoper, b=b, x0=X.reshape(-1)) # conjugate gradients
state = x.reshape(dim, dN, dN) + E
flux = dot(Cex, state)

AH_11 = np.sum(flux*state)/dN**dim # homogenised properties
print('homogenised coefficient (component 11) =', AH_11)

print('END')
